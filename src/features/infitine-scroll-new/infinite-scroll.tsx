import { useGSAP } from '@gsap/react';import gsap from 'gsap';import React, { useMemo, useRef } from 'react';import { cn } from '@/utils';gsap.registerPlugin(useGSAP);type InfiniteScrollProps = {	speed?: number;	gap?: number;	isReversed?: boolean;	isVertical?: boolean;	doesSlowOnHover?: boolean;	hasBlurredEdge?: boolean;	className?: string;	objList: any[];	ItemEl: React.FC<any>;};export const InfiniteScrollLoop: React.FC<InfiniteScrollProps> = ({	speed = 20,	gap = 8,	isReversed = false,	isVertical = false,	doesSlowOnHover = true,	className,	objList,	ItemEl,	hasBlurredEdge = false,}) => {	const containerRef = useRef<HTMLDivElement>(null);	const timeline = useRef<GSAPTimeline>();	const timelineTimeScaleTween = useRef<GSAPTween>();	const gapTw = `gap-${gap}`;	const marginRightTw = `mr-${gap}`;	const marginBottomTw = `mb-${gap}`;	useGSAP(		() => {			const setupInfiniteMarqueeTimeline = () => {				gsap.set(containerRef.current, {					yPercent: isReversed && isVertical ? -50 : 0,					xPercent: isReversed && !isVertical ? -50 : 0,				});				timeline.current = gsap					.timeline({						defaults: { ease: 'none', repeat: -1 },					})					.to(containerRef.current, {						yPercent: isReversed || !isVertical ? 0 : -50,						xPercent: isReversed || isVertical ? 0 : -50,						duration: speed,					})					.set(containerRef.current, { yPercent: 0, xPercent: 0 });			};			setupInfiniteMarqueeTimeline();		},		{ dependencies: [isReversed] },	);	const onPointerEnter = () => {		if (!timeline.current || !doesSlowOnHover) return;		timelineTimeScaleTween.current?.kill();		timelineTimeScaleTween.current = gsap.to(timeline.current, {			timeScale: 0.5,			duration: 0.4,		});	};	const onPointerLeave = () => {		if (!timeline.current || !doesSlowOnHover) return;		timelineTimeScaleTween.current?.kill();		timelineTimeScaleTween.current = gsap.to(timeline.current, {			timeScale: 1,			duration: 0.4,		});	};	const list = useMemo(() => {		const elements = [...objList, ...objList];		return (			<div				className={cn(					'flex',					gapTw,					isVertical						? 'flex-col h-fit justify-center'						: 'flex-row w-fit items-center',				)}			>				{elements.map((src, index) => {					const isLast = index === elements.length - 1;					return (						<div							key={index}							className={cn(								'relative flex h-fit w-fit items-center justify-center shrink-0',								isLast &&									(isVertical										? marginBottomTw										: marginRightTw),							)}						>							<ItemEl index={index} {...src} />						</div>					);				})}			</div>		);	}, [ItemEl, isVertical, objList]);	return (		<div			className={cn(				'select-none overflow-hidden',				isVertical ? 'max-h-full' : 'max-w-full',				className,			)}			onPointerEnter={onPointerEnter}			onPointerLeave={onPointerLeave}			style={{				maskImage: hasBlurredEdge					? isVertical						? `linear-gradient(to bottom, transparent 0%, black 25%, black 75%, transparent 100%)`						: `linear-gradient(to right, transparent 0%, black 25%, black 75%, transparent 100%)`					: undefined,			}}		>			<div				ref={containerRef}				className={cn(					'flex text-nowrap',					isVertical ? 'flex-col h-fit' : 'w-fit',				)}			>				{list}				{list}			</div>		</div>	);};